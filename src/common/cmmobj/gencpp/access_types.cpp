/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "access_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




CGate::~CGate() throw() {
}


void CGate::__set_gateID(const std::string& val) {
  this->gateID = val;
}

uint32_t CGate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gateID);
          this->__isset.gateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CGate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CGate");

  xfer += oprot->writeFieldBegin("gateID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->gateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CGate &a, CGate &b) {
  using ::std::swap;
  swap(a.gateID, b.gateID);
  swap(a.__isset, b.__isset);
}

CGate::CGate(const CGate& other0) {
  gateID = other0.gateID;
  __isset = other0.__isset;
}
CGate& CGate::operator=(const CGate& other1) {
  gateID = other1.gateID;
  __isset = other1.__isset;
  return *this;
}
void CGate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CGate(";
  out << "gateID=" << to_string(gateID);
  out << ")";
}


CBtyAlarm::~CBtyAlarm() throw() {
}


void CBtyAlarm::__set_almNO(const std::string& val) {
  this->almNO = val;
}

void CBtyAlarm::__set_gateID(const std::string& val) {
  this->gateID = val;
}

void CBtyAlarm::__set_bankID(const std::string& val) {
  this->bankID = val;
}

void CBtyAlarm::__set_cellID(const std::string& val) {
  this->cellID = val;
}

void CBtyAlarm::__set_kind(const int32_t val) {
  this->kind = val;
}

void CBtyAlarm::__set_level(const int32_t val) {
  this->level = val;
}

void CBtyAlarm::__set_value(const double val) {
  this->value = val;
}

void CBtyAlarm::__set_bTime(const int64_t val) {
  this->bTime = val;
}

void CBtyAlarm::__set_eTime(const int64_t val) {
  this->eTime = val;
}

uint32_t CBtyAlarm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->almNO);
          this->__isset.almNO = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gateID);
          this->__isset.gateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bankID);
          this->__isset.bankID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cellID);
          this->__isset.cellID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->kind);
          this->__isset.kind = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->bTime);
          this->__isset.bTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eTime);
          this->__isset.eTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBtyAlarm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBtyAlarm");

  xfer += oprot->writeFieldBegin("almNO", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->almNO);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gateID", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->gateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bankID", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->bankID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cellID", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->cellID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kind", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->kind);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bTime", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->bTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eTime", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->eTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBtyAlarm &a, CBtyAlarm &b) {
  using ::std::swap;
  swap(a.almNO, b.almNO);
  swap(a.gateID, b.gateID);
  swap(a.bankID, b.bankID);
  swap(a.cellID, b.cellID);
  swap(a.kind, b.kind);
  swap(a.level, b.level);
  swap(a.value, b.value);
  swap(a.bTime, b.bTime);
  swap(a.eTime, b.eTime);
  swap(a.__isset, b.__isset);
}

CBtyAlarm::CBtyAlarm(const CBtyAlarm& other2) {
  almNO = other2.almNO;
  gateID = other2.gateID;
  bankID = other2.bankID;
  cellID = other2.cellID;
  kind = other2.kind;
  level = other2.level;
  value = other2.value;
  bTime = other2.bTime;
  eTime = other2.eTime;
  __isset = other2.__isset;
}
CBtyAlarm& CBtyAlarm::operator=(const CBtyAlarm& other3) {
  almNO = other3.almNO;
  gateID = other3.gateID;
  bankID = other3.bankID;
  cellID = other3.cellID;
  kind = other3.kind;
  level = other3.level;
  value = other3.value;
  bTime = other3.bTime;
  eTime = other3.eTime;
  __isset = other3.__isset;
  return *this;
}
void CBtyAlarm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBtyAlarm(";
  out << "almNO=" << to_string(almNO);
  out << ", " << "gateID=" << to_string(gateID);
  out << ", " << "bankID=" << to_string(bankID);
  out << ", " << "cellID=" << to_string(cellID);
  out << ", " << "kind=" << to_string(kind);
  out << ", " << "level=" << to_string(level);
  out << ", " << "value=" << to_string(value);
  out << ", " << "bTime=" << to_string(bTime);
  out << ", " << "eTime=" << to_string(eTime);
  out << ")";
}


CBtyData::~CBtyData() throw() {
}


void CBtyData::__set_vol(const double val) {
  this->vol = val;
}

void CBtyData::__set_cur(const double val) {
  this->cur = val;
}

void CBtyData::__set_temp(const double val) {
  this->temp = val;
}

void CBtyData::__set_stats(const std::vector<int32_t> & val) {
  this->stats = val;
}

void CBtyData::__set_time(const int64_t val) {
  this->time = val;
}

uint32_t CBtyData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->vol);
          this->__isset.vol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cur);
          this->__isset.cur = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->temp);
          this->__isset.temp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stats.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->stats.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += iprot->readI32(this->stats[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBtyData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBtyData");

  xfer += oprot->writeFieldBegin("vol", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->vol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cur", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->cur);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("temp", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->temp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stats", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->stats.size()));
    std::vector<int32_t> ::const_iterator _iter9;
    for (_iter9 = this->stats.begin(); _iter9 != this->stats.end(); ++_iter9)
    {
      xfer += oprot->writeI32((*_iter9));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBtyData &a, CBtyData &b) {
  using ::std::swap;
  swap(a.vol, b.vol);
  swap(a.cur, b.cur);
  swap(a.temp, b.temp);
  swap(a.stats, b.stats);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

CBtyData::CBtyData(const CBtyData& other10) {
  vol = other10.vol;
  cur = other10.cur;
  temp = other10.temp;
  stats = other10.stats;
  time = other10.time;
  __isset = other10.__isset;
}
CBtyData& CBtyData::operator=(const CBtyData& other11) {
  vol = other11.vol;
  cur = other11.cur;
  temp = other11.temp;
  stats = other11.stats;
  time = other11.time;
  __isset = other11.__isset;
  return *this;
}
void CBtyData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBtyData(";
  out << "vol=" << to_string(vol);
  out << ", " << "cur=" << to_string(cur);
  out << ", " << "temp=" << to_string(temp);
  out << ", " << "stats=" << to_string(stats);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


CBtyCellData::~CBtyCellData() throw() {
}


void CBtyCellData::__set_devID(const std::string& val) {
  this->devID = val;
}

void CBtyCellData::__set_index(const int32_t val) {
  this->index = val;
}

void CBtyCellData::__set_values(const std::vector<CBtyData> & val) {
  this->values = val;
}

uint32_t CBtyCellData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devID);
          this->__isset.devID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->values.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->values[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBtyCellData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBtyCellData");

  xfer += oprot->writeFieldBegin("devID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->devID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<CBtyData> ::const_iterator _iter17;
    for (_iter17 = this->values.begin(); _iter17 != this->values.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBtyCellData &a, CBtyCellData &b) {
  using ::std::swap;
  swap(a.devID, b.devID);
  swap(a.index, b.index);
  swap(a.values, b.values);
  swap(a.__isset, b.__isset);
}

CBtyCellData::CBtyCellData(const CBtyCellData& other18) {
  devID = other18.devID;
  index = other18.index;
  values = other18.values;
  __isset = other18.__isset;
}
CBtyCellData& CBtyCellData::operator=(const CBtyCellData& other19) {
  devID = other19.devID;
  index = other19.index;
  values = other19.values;
  __isset = other19.__isset;
  return *this;
}
void CBtyCellData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBtyCellData(";
  out << "devID=" << to_string(devID);
  out << ", " << "index=" << to_string(index);
  out << ", " << "values=" << to_string(values);
  out << ")";
}


CBtyBankData::~CBtyBankData() throw() {
}


void CBtyBankData::__set_devID(const std::string& val) {
  this->devID = val;
}

void CBtyBankData::__set_value(const CBtyData& val) {
  this->value = val;
}

void CBtyBankData::__set_totalChg(const int32_t val) {
  this->totalChg = val;
}

void CBtyBankData::__set_totalDischg(const int32_t val) {
  this->totalDischg = val;
}

void CBtyBankData::__set_cells(const std::vector<CBtyCellData> & val) {
  this->cells = val;
}

uint32_t CBtyBankData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devID);
          this->__isset.devID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalChg);
          this->__isset.totalChg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalDischg);
          this->__isset.totalDischg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->cells.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->cells[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBtyBankData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBtyBankData");

  xfer += oprot->writeFieldBegin("devID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->devID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalChg", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->totalChg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalDischg", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->totalDischg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<CBtyCellData> ::const_iterator _iter25;
    for (_iter25 = this->cells.begin(); _iter25 != this->cells.end(); ++_iter25)
    {
      xfer += (*_iter25).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBtyBankData &a, CBtyBankData &b) {
  using ::std::swap;
  swap(a.devID, b.devID);
  swap(a.value, b.value);
  swap(a.totalChg, b.totalChg);
  swap(a.totalDischg, b.totalDischg);
  swap(a.cells, b.cells);
  swap(a.__isset, b.__isset);
}

CBtyBankData::CBtyBankData(const CBtyBankData& other26) {
  devID = other26.devID;
  value = other26.value;
  totalChg = other26.totalChg;
  totalDischg = other26.totalDischg;
  cells = other26.cells;
  __isset = other26.__isset;
}
CBtyBankData& CBtyBankData::operator=(const CBtyBankData& other27) {
  devID = other27.devID;
  value = other27.value;
  totalChg = other27.totalChg;
  totalDischg = other27.totalDischg;
  cells = other27.cells;
  __isset = other27.__isset;
  return *this;
}
void CBtyBankData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBtyBankData(";
  out << "devID=" << to_string(devID);
  out << ", " << "value=" << to_string(value);
  out << ", " << "totalChg=" << to_string(totalChg);
  out << ", " << "totalDischg=" << to_string(totalDischg);
  out << ", " << "cells=" << to_string(cells);
  out << ")";
}


CBtyBankStatus::~CBtyBankStatus() throw() {
}


void CBtyBankStatus::__set_devID(const std::string& val) {
  this->devID = val;
}

void CBtyBankStatus::__set_status(const int32_t val) {
  this->status = val;
}

void CBtyBankStatus::__set_time(const int64_t val) {
  this->time = val;
}

uint32_t CBtyBankStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devID);
          this->__isset.devID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBtyBankStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBtyBankStatus");

  xfer += oprot->writeFieldBegin("devID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->devID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBtyBankStatus &a, CBtyBankStatus &b) {
  using ::std::swap;
  swap(a.devID, b.devID);
  swap(a.status, b.status);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

CBtyBankStatus::CBtyBankStatus(const CBtyBankStatus& other28) {
  devID = other28.devID;
  status = other28.status;
  time = other28.time;
  __isset = other28.__isset;
}
CBtyBankStatus& CBtyBankStatus::operator=(const CBtyBankStatus& other29) {
  devID = other29.devID;
  status = other29.status;
  time = other29.time;
  __isset = other29.__isset;
  return *this;
}
void CBtyBankStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBtyBankStatus(";
  out << "devID=" << to_string(devID);
  out << ", " << "status=" << to_string(status);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


CBatteryCellData::~CBatteryCellData() throw() {
}


void CBatteryCellData::__set_devID(const std::string& val) {
  this->devID = val;
}

void CBatteryCellData::__set_v(const double val) {
  this->v = val;
}

void CBatteryCellData::__set_c(const double val) {
  this->c = val;
}

void CBatteryCellData::__set_t(const double val) {
  this->t = val;
}

void CBatteryCellData::__set_battStatus(const std::vector<int32_t> & val) {
  this->battStatus = val;
}

void CBatteryCellData::__set_cStatus(const int32_t val) {
  this->cStatus = val;
}

void CBatteryCellData::__set_bankStatus(const std::vector<int32_t> & val) {
  this->bankStatus = val;
}

uint32_t CBatteryCellData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devID);
          this->__isset.devID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->t);
          this->__isset.t = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->battStatus.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->battStatus.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += iprot->readI32(this->battStatus[_i34]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.battStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cStatus);
          this->__isset.cStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bankStatus.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->bankStatus.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += iprot->readI32(this->bankStatus[_i39]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bankStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBatteryCellData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBatteryCellData");

  xfer += oprot->writeFieldBegin("devID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->devID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("t", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->t);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("battStatus", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->battStatus.size()));
    std::vector<int32_t> ::const_iterator _iter40;
    for (_iter40 = this->battStatus.begin(); _iter40 != this->battStatus.end(); ++_iter40)
    {
      xfer += oprot->writeI32((*_iter40));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cStatus", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->cStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bankStatus", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->bankStatus.size()));
    std::vector<int32_t> ::const_iterator _iter41;
    for (_iter41 = this->bankStatus.begin(); _iter41 != this->bankStatus.end(); ++_iter41)
    {
      xfer += oprot->writeI32((*_iter41));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBatteryCellData &a, CBatteryCellData &b) {
  using ::std::swap;
  swap(a.devID, b.devID);
  swap(a.v, b.v);
  swap(a.c, b.c);
  swap(a.t, b.t);
  swap(a.battStatus, b.battStatus);
  swap(a.cStatus, b.cStatus);
  swap(a.bankStatus, b.bankStatus);
  swap(a.__isset, b.__isset);
}

CBatteryCellData::CBatteryCellData(const CBatteryCellData& other42) {
  devID = other42.devID;
  v = other42.v;
  c = other42.c;
  t = other42.t;
  battStatus = other42.battStatus;
  cStatus = other42.cStatus;
  bankStatus = other42.bankStatus;
  __isset = other42.__isset;
}
CBatteryCellData& CBatteryCellData::operator=(const CBatteryCellData& other43) {
  devID = other43.devID;
  v = other43.v;
  c = other43.c;
  t = other43.t;
  battStatus = other43.battStatus;
  cStatus = other43.cStatus;
  bankStatus = other43.bankStatus;
  __isset = other43.__isset;
  return *this;
}
void CBatteryCellData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBatteryCellData(";
  out << "devID=" << to_string(devID);
  out << ", " << "v=" << to_string(v);
  out << ", " << "c=" << to_string(c);
  out << ", " << "t=" << to_string(t);
  out << ", " << "battStatus=" << to_string(battStatus);
  out << ", " << "cStatus=" << to_string(cStatus);
  out << ", " << "bankStatus=" << to_string(bankStatus);
  out << ")";
}


CBatteryData::~CBatteryData() throw() {
}


void CBatteryData::__set_time(const int64_t val) {
  this->time = val;
}

void CBatteryData::__set_v(const double val) {
  this->v = val;
}

void CBatteryData::__set_c(const double val) {
  this->c = val;
}

void CBatteryData::__set_cells(const std::vector<CBatteryCellData> & val) {
  this->cells = val;
}

uint32_t CBatteryData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _etype47;
            xfer += iprot->readListBegin(_etype47, _size44);
            this->cells.resize(_size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              xfer += this->cells[_i48].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBatteryData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBatteryData");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<CBatteryCellData> ::const_iterator _iter49;
    for (_iter49 = this->cells.begin(); _iter49 != this->cells.end(); ++_iter49)
    {
      xfer += (*_iter49).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBatteryData &a, CBatteryData &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.v, b.v);
  swap(a.c, b.c);
  swap(a.cells, b.cells);
  swap(a.__isset, b.__isset);
}

CBatteryData::CBatteryData(const CBatteryData& other50) {
  time = other50.time;
  v = other50.v;
  c = other50.c;
  cells = other50.cells;
  __isset = other50.__isset;
}
CBatteryData& CBatteryData::operator=(const CBatteryData& other51) {
  time = other51.time;
  v = other51.v;
  c = other51.c;
  cells = other51.cells;
  __isset = other51.__isset;
  return *this;
}
void CBatteryData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBatteryData(";
  out << "time=" << to_string(time);
  out << ", " << "v=" << to_string(v);
  out << ", " << "c=" << to_string(c);
  out << ", " << "cells=" << to_string(cells);
  out << ")";
}


CBatteryBankData::~CBatteryBankData() throw() {
}


void CBatteryBankData::__set_devID(const std::string& val) {
  this->devID = val;
}

void CBatteryBankData::__set_totalChg(const int32_t val) {
  this->totalChg = val;
}

void CBatteryBankData::__set_totalDischg(const int32_t val) {
  this->totalDischg = val;
}

void CBatteryBankData::__set_temp(const double val) {
  this->temp = val;
}

void CBatteryBankData::__set_zone(const int32_t val) {
  this->zone = val;
}

void CBatteryBankData::__set_datas(const std::vector<CBatteryData> & val) {
  this->datas = val;
}

uint32_t CBatteryBankData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devID);
          this->__isset.devID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalChg);
          this->__isset.totalChg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalDischg);
          this->__isset.totalDischg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->temp);
          this->__isset.temp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->zone);
          this->__isset.zone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->datas.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->datas.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->datas[_i56].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.datas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBatteryBankData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBatteryBankData");

  xfer += oprot->writeFieldBegin("devID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->devID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalChg", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->totalChg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalDischg", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->totalDischg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("temp", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->temp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zone", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->zone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("datas", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->datas.size()));
    std::vector<CBatteryData> ::const_iterator _iter57;
    for (_iter57 = this->datas.begin(); _iter57 != this->datas.end(); ++_iter57)
    {
      xfer += (*_iter57).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBatteryBankData &a, CBatteryBankData &b) {
  using ::std::swap;
  swap(a.devID, b.devID);
  swap(a.totalChg, b.totalChg);
  swap(a.totalDischg, b.totalDischg);
  swap(a.temp, b.temp);
  swap(a.zone, b.zone);
  swap(a.datas, b.datas);
  swap(a.__isset, b.__isset);
}

CBatteryBankData::CBatteryBankData(const CBatteryBankData& other58) {
  devID = other58.devID;
  totalChg = other58.totalChg;
  totalDischg = other58.totalDischg;
  temp = other58.temp;
  zone = other58.zone;
  datas = other58.datas;
  __isset = other58.__isset;
}
CBatteryBankData& CBatteryBankData::operator=(const CBatteryBankData& other59) {
  devID = other59.devID;
  totalChg = other59.totalChg;
  totalDischg = other59.totalDischg;
  temp = other59.temp;
  zone = other59.zone;
  datas = other59.datas;
  __isset = other59.__isset;
  return *this;
}
void CBatteryBankData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBatteryBankData(";
  out << "devID=" << to_string(devID);
  out << ", " << "totalChg=" << to_string(totalChg);
  out << ", " << "totalDischg=" << to_string(totalDischg);
  out << ", " << "temp=" << to_string(temp);
  out << ", " << "zone=" << to_string(zone);
  out << ", " << "datas=" << to_string(datas);
  out << ")";
}


CBtyCmd::~CBtyCmd() throw() {
}


void CBtyCmd::__set_gateID(const std::string& val) {
  this->gateID = val;
}

void CBtyCmd::__set_devID(const std::string& val) {
  this->devID = val;
}

uint32_t CBtyCmd::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gateID);
          this->__isset.gateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devID);
          this->__isset.devID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBtyCmd::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBtyCmd");

  xfer += oprot->writeFieldBegin("gateID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->gateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devID", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->devID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBtyCmd &a, CBtyCmd &b) {
  using ::std::swap;
  swap(a.gateID, b.gateID);
  swap(a.devID, b.devID);
  swap(a.__isset, b.__isset);
}

CBtyCmd::CBtyCmd(const CBtyCmd& other60) {
  gateID = other60.gateID;
  devID = other60.devID;
  __isset = other60.__isset;
}
CBtyCmd& CBtyCmd::operator=(const CBtyCmd& other61) {
  gateID = other61.gateID;
  devID = other61.devID;
  __isset = other61.__isset;
  return *this;
}
void CBtyCmd::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBtyCmd(";
  out << "gateID=" << to_string(gateID);
  out << ", " << "devID=" << to_string(devID);
  out << ")";
}


CBtyResTestCmd::~CBtyResTestCmd() throw() {
}


void CBtyResTestCmd::__set_gateID(const std::string& val) {
  this->gateID = val;
}

void CBtyResTestCmd::__set_bankID(const std::string& val) {
  this->bankID = val;
}

void CBtyResTestCmd::__set_cmd(const int32_t val) {
  this->cmd = val;
}

uint32_t CBtyResTestCmd::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gateID);
          this->__isset.gateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bankID);
          this->__isset.bankID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cmd);
          this->__isset.cmd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBtyResTestCmd::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBtyResTestCmd");

  xfer += oprot->writeFieldBegin("gateID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->gateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bankID", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->bankID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmd", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->cmd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBtyResTestCmd &a, CBtyResTestCmd &b) {
  using ::std::swap;
  swap(a.gateID, b.gateID);
  swap(a.bankID, b.bankID);
  swap(a.cmd, b.cmd);
  swap(a.__isset, b.__isset);
}

CBtyResTestCmd::CBtyResTestCmd(const CBtyResTestCmd& other62) {
  gateID = other62.gateID;
  bankID = other62.bankID;
  cmd = other62.cmd;
  __isset = other62.__isset;
}
CBtyResTestCmd& CBtyResTestCmd::operator=(const CBtyResTestCmd& other63) {
  gateID = other63.gateID;
  bankID = other63.bankID;
  cmd = other63.cmd;
  __isset = other63.__isset;
  return *this;
}
void CBtyResTestCmd::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBtyResTestCmd(";
  out << "gateID=" << to_string(gateID);
  out << ", " << "bankID=" << to_string(bankID);
  out << ", " << "cmd=" << to_string(cmd);
  out << ")";
}


CBatteryResData::~CBatteryResData() throw() {
}


void CBatteryResData::__set_bankID(const std::string& val) {
  this->bankID = val;
}

void CBatteryResData::__set_battID(const std::string& val) {
  this->battID = val;
}

void CBatteryResData::__set_time(const int64_t val) {
  this->time = val;
}

void CBatteryResData::__set_res(const double val) {
  this->res = val;
}

uint32_t CBatteryResData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bankID);
          this->__isset.bankID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->battID);
          this->__isset.battID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->res);
          this->__isset.res = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBatteryResData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBatteryResData");

  xfer += oprot->writeFieldBegin("bankID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bankID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("battID", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->battID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("res", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->res);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBatteryResData &a, CBatteryResData &b) {
  using ::std::swap;
  swap(a.bankID, b.bankID);
  swap(a.battID, b.battID);
  swap(a.time, b.time);
  swap(a.res, b.res);
  swap(a.__isset, b.__isset);
}

CBatteryResData::CBatteryResData(const CBatteryResData& other64) {
  bankID = other64.bankID;
  battID = other64.battID;
  time = other64.time;
  res = other64.res;
  __isset = other64.__isset;
}
CBatteryResData& CBatteryResData::operator=(const CBatteryResData& other65) {
  bankID = other65.bankID;
  battID = other65.battID;
  time = other65.time;
  res = other65.res;
  __isset = other65.__isset;
  return *this;
}
void CBatteryResData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBatteryResData(";
  out << "bankID=" << to_string(bankID);
  out << ", " << "battID=" << to_string(battID);
  out << ", " << "time=" << to_string(time);
  out << ", " << "res=" << to_string(res);
  out << ")";
}


CGeneralData::~CGeneralData() throw() {
}


void CGeneralData::__set_devType(const int32_t val) {
  this->devType = val;
}

void CGeneralData::__set_devID(const std::string& val) {
  this->devID = val;
}

void CGeneralData::__set_meters(const std::vector<double> & val) {
  this->meters = val;
}

void CGeneralData::__set_signals(const std::vector<int32_t> & val) {
  this->signals = val;
}

uint32_t CGeneralData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->devType);
          this->__isset.devType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devID);
          this->__isset.devID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->meters.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            xfer += iprot->readListBegin(_etype69, _size66);
            this->meters.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += iprot->readDouble(this->meters[_i70]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.meters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->signals.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->signals.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += iprot->readI32(this->signals[_i75]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.signals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CGeneralData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CGeneralData");

  xfer += oprot->writeFieldBegin("devType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->devType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devID", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->devID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("meters", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->meters.size()));
    std::vector<double> ::const_iterator _iter76;
    for (_iter76 = this->meters.begin(); _iter76 != this->meters.end(); ++_iter76)
    {
      xfer += oprot->writeDouble((*_iter76));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signals", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->signals.size()));
    std::vector<int32_t> ::const_iterator _iter77;
    for (_iter77 = this->signals.begin(); _iter77 != this->signals.end(); ++_iter77)
    {
      xfer += oprot->writeI32((*_iter77));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CGeneralData &a, CGeneralData &b) {
  using ::std::swap;
  swap(a.devType, b.devType);
  swap(a.devID, b.devID);
  swap(a.meters, b.meters);
  swap(a.signals, b.signals);
  swap(a.__isset, b.__isset);
}

CGeneralData::CGeneralData(const CGeneralData& other78) {
  devType = other78.devType;
  devID = other78.devID;
  meters = other78.meters;
  signals = other78.signals;
  __isset = other78.__isset;
}
CGeneralData& CGeneralData::operator=(const CGeneralData& other79) {
  devType = other79.devType;
  devID = other79.devID;
  meters = other79.meters;
  signals = other79.signals;
  __isset = other79.__isset;
  return *this;
}
void CGeneralData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CGeneralData(";
  out << "devType=" << to_string(devType);
  out << ", " << "devID=" << to_string(devID);
  out << ", " << "meters=" << to_string(meters);
  out << ", " << "signals=" << to_string(signals);
  out << ")";
}


CMeterData::~CMeterData() throw() {
}


void CMeterData::__set_devType(const int32_t val) {
  this->devType = val;
}

void CMeterData::__set_devID(const std::string& val) {
  this->devID = val;
}

void CMeterData::__set_ms(const std::map<std::string, double> & val) {
  this->ms = val;
}

void CMeterData::__set_ss(const std::map<std::string, int32_t> & val) {
  this->ss = val;
}

uint32_t CMeterData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->devType);
          this->__isset.devType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devID);
          this->__isset.devID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ms.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _ktype81;
            ::apache::thrift::protocol::TType _vtype82;
            xfer += iprot->readMapBegin(_ktype81, _vtype82, _size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              std::string _key85;
              xfer += iprot->readString(_key85);
              double& _val86 = this->ms[_key85];
              xfer += iprot->readDouble(_val86);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ss.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _ktype88;
            ::apache::thrift::protocol::TType _vtype89;
            xfer += iprot->readMapBegin(_ktype88, _vtype89, _size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              std::string _key92;
              xfer += iprot->readString(_key92);
              int32_t& _val93 = this->ss[_key92];
              xfer += iprot->readI32(_val93);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMeterData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMeterData");

  xfer += oprot->writeFieldBegin("devType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->devType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devID", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->devID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ms", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->ms.size()));
    std::map<std::string, double> ::const_iterator _iter94;
    for (_iter94 = this->ms.begin(); _iter94 != this->ms.end(); ++_iter94)
    {
      xfer += oprot->writeString(_iter94->first);
      xfer += oprot->writeDouble(_iter94->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ss", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->ss.size()));
    std::map<std::string, int32_t> ::const_iterator _iter95;
    for (_iter95 = this->ss.begin(); _iter95 != this->ss.end(); ++_iter95)
    {
      xfer += oprot->writeString(_iter95->first);
      xfer += oprot->writeI32(_iter95->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMeterData &a, CMeterData &b) {
  using ::std::swap;
  swap(a.devType, b.devType);
  swap(a.devID, b.devID);
  swap(a.ms, b.ms);
  swap(a.ss, b.ss);
  swap(a.__isset, b.__isset);
}

CMeterData::CMeterData(const CMeterData& other96) {
  devType = other96.devType;
  devID = other96.devID;
  ms = other96.ms;
  ss = other96.ss;
  __isset = other96.__isset;
}
CMeterData& CMeterData::operator=(const CMeterData& other97) {
  devType = other97.devType;
  devID = other97.devID;
  ms = other97.ms;
  ss = other97.ss;
  __isset = other97.__isset;
  return *this;
}
void CMeterData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMeterData(";
  out << "devType=" << to_string(devType);
  out << ", " << "devID=" << to_string(devID);
  out << ", " << "ms=" << to_string(ms);
  out << ", " << "ss=" << to_string(ss);
  out << ")";
}


CConfigData::~CConfigData() throw() {
}


void CConfigData::__set_devType(const int32_t val) {
  this->devType = val;
}

void CConfigData::__set_devID(const std::string& val) {
  this->devID = val;
}

void CConfigData::__set_cs(const std::map<std::string, std::string> & val) {
  this->cs = val;
}

void CConfigData::__set_cr(const std::map<std::string, bool> & val) {
  this->cr = val;
}

uint32_t CConfigData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->devType);
          this->__isset.devType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->devID);
          this->__isset.devID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cs.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _ktype99;
            ::apache::thrift::protocol::TType _vtype100;
            xfer += iprot->readMapBegin(_ktype99, _vtype100, _size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              std::string _key103;
              xfer += iprot->readString(_key103);
              std::string& _val104 = this->cs[_key103];
              xfer += iprot->readString(_val104);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cr.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _ktype106;
            ::apache::thrift::protocol::TType _vtype107;
            xfer += iprot->readMapBegin(_ktype106, _vtype107, _size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              std::string _key110;
              xfer += iprot->readString(_key110);
              bool& _val111 = this->cr[_key110];
              xfer += iprot->readBool(_val111);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CConfigData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CConfigData");

  xfer += oprot->writeFieldBegin("devType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->devType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devID", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->devID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cs", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cs.size()));
    std::map<std::string, std::string> ::const_iterator _iter112;
    for (_iter112 = this->cs.begin(); _iter112 != this->cs.end(); ++_iter112)
    {
      xfer += oprot->writeString(_iter112->first);
      xfer += oprot->writeString(_iter112->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cr", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->cr.size()));
    std::map<std::string, bool> ::const_iterator _iter113;
    for (_iter113 = this->cr.begin(); _iter113 != this->cr.end(); ++_iter113)
    {
      xfer += oprot->writeString(_iter113->first);
      xfer += oprot->writeBool(_iter113->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CConfigData &a, CConfigData &b) {
  using ::std::swap;
  swap(a.devType, b.devType);
  swap(a.devID, b.devID);
  swap(a.cs, b.cs);
  swap(a.cr, b.cr);
  swap(a.__isset, b.__isset);
}

CConfigData::CConfigData(const CConfigData& other114) {
  devType = other114.devType;
  devID = other114.devID;
  cs = other114.cs;
  cr = other114.cr;
  __isset = other114.__isset;
}
CConfigData& CConfigData::operator=(const CConfigData& other115) {
  devType = other115.devType;
  devID = other115.devID;
  cs = other115.cs;
  cr = other115.cr;
  __isset = other115.__isset;
  return *this;
}
void CConfigData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CConfigData(";
  out << "devType=" << to_string(devType);
  out << ", " << "devID=" << to_string(devID);
  out << ", " << "cs=" << to_string(cs);
  out << ", " << "cr=" << to_string(cr);
  out << ")";
}


CAppInfo::~CAppInfo() throw() {
}


void CAppInfo::__set_appID(const std::string& val) {
  this->appID = val;
}

void CAppInfo::__set_appVer(const std::string& val) {
  this->appVer = val;
}

uint32_t CAppInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appID);
          this->__isset.appID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appVer);
          this->__isset.appVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CAppInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CAppInfo");

  xfer += oprot->writeFieldBegin("appID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->appID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appVer", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->appVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CAppInfo &a, CAppInfo &b) {
  using ::std::swap;
  swap(a.appID, b.appID);
  swap(a.appVer, b.appVer);
  swap(a.__isset, b.__isset);
}

CAppInfo::CAppInfo(const CAppInfo& other116) {
  appID = other116.appID;
  appVer = other116.appVer;
  __isset = other116.__isset;
}
CAppInfo& CAppInfo::operator=(const CAppInfo& other117) {
  appID = other117.appID;
  appVer = other117.appVer;
  __isset = other117.__isset;
  return *this;
}
void CAppInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CAppInfo(";
  out << "appID=" << to_string(appID);
  out << ", " << "appVer=" << to_string(appVer);
  out << ")";
}


CAppUpdataCmd::~CAppUpdataCmd() throw() {
}


void CAppUpdataCmd::__set_type(const int32_t val) {
  this->type = val;
}

void CAppUpdataCmd::__set_gateID(const std::string& val) {
  this->gateID = val;
}

void CAppUpdataCmd::__set_len(const int32_t val) {
  this->len = val;
}

void CAppUpdataCmd::__set_appID(const std::string& val) {
  this->appID = val;
}

void CAppUpdataCmd::__set_appVer(const std::string& val) {
  this->appVer = val;
}

void CAppUpdataCmd::__set_appUrl1(const std::string& val) {
  this->appUrl1 = val;
}

void CAppUpdataCmd::__set_appUrl2(const std::string& val) {
  this->appUrl2 = val;
}

uint32_t CAppUpdataCmd::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gateID);
          this->__isset.gateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appID);
          this->__isset.appID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appVer);
          this->__isset.appVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appUrl1);
          this->__isset.appUrl1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appUrl2);
          this->__isset.appUrl2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CAppUpdataCmd::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CAppUpdataCmd");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gateID", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->gateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->len);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appID", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->appID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appVer", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->appVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appUrl1", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->appUrl1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appUrl2", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->appUrl2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CAppUpdataCmd &a, CAppUpdataCmd &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.gateID, b.gateID);
  swap(a.len, b.len);
  swap(a.appID, b.appID);
  swap(a.appVer, b.appVer);
  swap(a.appUrl1, b.appUrl1);
  swap(a.appUrl2, b.appUrl2);
  swap(a.__isset, b.__isset);
}

CAppUpdataCmd::CAppUpdataCmd(const CAppUpdataCmd& other118) {
  type = other118.type;
  gateID = other118.gateID;
  len = other118.len;
  appID = other118.appID;
  appVer = other118.appVer;
  appUrl1 = other118.appUrl1;
  appUrl2 = other118.appUrl2;
  __isset = other118.__isset;
}
CAppUpdataCmd& CAppUpdataCmd::operator=(const CAppUpdataCmd& other119) {
  type = other119.type;
  gateID = other119.gateID;
  len = other119.len;
  appID = other119.appID;
  appVer = other119.appVer;
  appUrl1 = other119.appUrl1;
  appUrl2 = other119.appUrl2;
  __isset = other119.__isset;
  return *this;
}
void CAppUpdataCmd::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CAppUpdataCmd(";
  out << "type=" << to_string(type);
  out << ", " << "gateID=" << to_string(gateID);
  out << ", " << "len=" << to_string(len);
  out << ", " << "appID=" << to_string(appID);
  out << ", " << "appVer=" << to_string(appVer);
  out << ", " << "appUrl1=" << to_string(appUrl1);
  out << ", " << "appUrl2=" << to_string(appUrl2);
  out << ")";
}


CAppUpdataStatus::~CAppUpdataStatus() throw() {
}


void CAppUpdataStatus::__set_type(const int32_t val) {
  this->type = val;
}

void CAppUpdataStatus::__set_gateID(const std::string& val) {
  this->gateID = val;
}

void CAppUpdataStatus::__set_appID(const std::string& val) {
  this->appID = val;
}

void CAppUpdataStatus::__set_appVer(const std::string& val) {
  this->appVer = val;
}

void CAppUpdataStatus::__set_status(const int32_t val) {
  this->status = val;
}

uint32_t CAppUpdataStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gateID);
          this->__isset.gateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appID);
          this->__isset.appID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appVer);
          this->__isset.appVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CAppUpdataStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CAppUpdataStatus");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gateID", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->gateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appID", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->appID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appVer", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->appVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CAppUpdataStatus &a, CAppUpdataStatus &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.gateID, b.gateID);
  swap(a.appID, b.appID);
  swap(a.appVer, b.appVer);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

CAppUpdataStatus::CAppUpdataStatus(const CAppUpdataStatus& other120) {
  type = other120.type;
  gateID = other120.gateID;
  appID = other120.appID;
  appVer = other120.appVer;
  status = other120.status;
  __isset = other120.__isset;
}
CAppUpdataStatus& CAppUpdataStatus::operator=(const CAppUpdataStatus& other121) {
  type = other121.type;
  gateID = other121.gateID;
  appID = other121.appID;
  appVer = other121.appVer;
  status = other121.status;
  __isset = other121.__isset;
  return *this;
}
void CAppUpdataStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CAppUpdataStatus(";
  out << "type=" << to_string(type);
  out << ", " << "gateID=" << to_string(gateID);
  out << ", " << "appID=" << to_string(appID);
  out << ", " << "appVer=" << to_string(appVer);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


CGateParams::~CGateParams() throw() {
}


void CGateParams::__set_gateID(const std::string& val) {
  this->gateID = val;
}

void CGateParams::__set_type(const int32_t val) {
  this->type = val;
}

void CGateParams::__set_num(const int32_t val) {
  this->num = val;
}

void CGateParams::__set_value(const double val) {
  this->value = val;
}

uint32_t CGateParams::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gateID);
          this->__isset.gateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          this->__isset.num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CGateParams::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CGateParams");

  xfer += oprot->writeFieldBegin("gateID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->gateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CGateParams &a, CGateParams &b) {
  using ::std::swap;
  swap(a.gateID, b.gateID);
  swap(a.type, b.type);
  swap(a.num, b.num);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

CGateParams::CGateParams(const CGateParams& other122) {
  gateID = other122.gateID;
  type = other122.type;
  num = other122.num;
  value = other122.value;
  __isset = other122.__isset;
}
CGateParams& CGateParams::operator=(const CGateParams& other123) {
  gateID = other123.gateID;
  type = other123.type;
  num = other123.num;
  value = other123.value;
  __isset = other123.__isset;
  return *this;
}
void CGateParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CGateParams(";
  out << "gateID=" << to_string(gateID);
  out << ", " << "type=" << to_string(type);
  out << ", " << "num=" << to_string(num);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


CSMS::~CSMS() throw() {
}


void CSMS::__set_gateID(const std::string& val) {
  this->gateID = val;
}

void CSMS::__set_number(const std::string& val) {
  this->number = val;
}

void CSMS::__set_content(const std::string& val) {
  this->content = val;
}

void CSMS::__set_time(const int64_t val) {
  this->time = val;
}

uint32_t CSMS::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gateID);
          this->__isset.gateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->number);
          this->__isset.number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSMS::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSMS");

  xfer += oprot->writeFieldBegin("gateID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->gateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->number);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSMS &a, CSMS &b) {
  using ::std::swap;
  swap(a.gateID, b.gateID);
  swap(a.number, b.number);
  swap(a.content, b.content);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

CSMS::CSMS(const CSMS& other124) {
  gateID = other124.gateID;
  number = other124.number;
  content = other124.content;
  time = other124.time;
  __isset = other124.__isset;
}
CSMS& CSMS::operator=(const CSMS& other125) {
  gateID = other125.gateID;
  number = other125.number;
  content = other125.content;
  time = other125.time;
  __isset = other125.__isset;
  return *this;
}
void CSMS::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSMS(";
  out << "gateID=" << to_string(gateID);
  out << ", " << "number=" << to_string(number);
  out << ", " << "content=" << to_string(content);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


CQuery::~CQuery() throw() {
}


void CQuery::__set_type(const int32_t val) {
  this->type = val;
}

void CQuery::__set_time(const int64_t val) {
  this->time = val;
}

void CQuery::__set_gateID(const std::string& val) {
  this->gateID = val;
}

void CQuery::__set_text(const std::string& val) {
  this->text = val;
}

uint32_t CQuery::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gateID);
          this->__isset.gateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CQuery::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CQuery");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gateID", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->gateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CQuery &a, CQuery &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.time, b.time);
  swap(a.gateID, b.gateID);
  swap(a.text, b.text);
  swap(a.__isset, b.__isset);
}

CQuery::CQuery(const CQuery& other126) {
  type = other126.type;
  time = other126.time;
  gateID = other126.gateID;
  text = other126.text;
  __isset = other126.__isset;
}
CQuery& CQuery::operator=(const CQuery& other127) {
  type = other127.type;
  time = other127.time;
  gateID = other127.gateID;
  text = other127.text;
  __isset = other127.__isset;
  return *this;
}
void CQuery::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CQuery(";
  out << "type=" << to_string(type);
  out << ", " << "time=" << to_string(time);
  out << ", " << "gateID=" << to_string(gateID);
  out << ", " << "text=" << to_string(text);
  out << ")";
}


CAlarm::~CAlarm() throw() {
}


void CAlarm::__set_devType(const int32_t val) {
  this->devType = val;
}

void CAlarm::__set_devIndex(const int32_t val) {
  this->devIndex = val;
}

void CAlarm::__set_almType(const int32_t val) {
  this->almType = val;
}

void CAlarm::__set_almIndex(const int32_t val) {
  this->almIndex = val;
}

void CAlarm::__set_almFlag(const int32_t val) {
  this->almFlag = val;
}

void CAlarm::__set_almNo(const std::string& val) {
  this->almNo = val;
}

void CAlarm::__set_almLimit(const double val) {
  this->almLimit = val;
}

void CAlarm::__set_almValue(const double val) {
  this->almValue = val;
}

void CAlarm::__set_almTime(const int64_t val) {
  this->almTime = val;
}

void CAlarm::__set_clearLimit(const double val) {
  this->clearLimit = val;
}

void CAlarm::__set_clearValue(const double val) {
  this->clearValue = val;
}

void CAlarm::__set_clearTime(const int64_t val) {
  this->clearTime = val;
}

uint32_t CAlarm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->devType);
          this->__isset.devType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->devIndex);
          this->__isset.devIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->almType);
          this->__isset.almType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->almIndex);
          this->__isset.almIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->almFlag);
          this->__isset.almFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->almNo);
          this->__isset.almNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->almLimit);
          this->__isset.almLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->almValue);
          this->__isset.almValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->almTime);
          this->__isset.almTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->clearLimit);
          this->__isset.clearLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->clearValue);
          this->__isset.clearValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->clearTime);
          this->__isset.clearTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CAlarm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CAlarm");

  xfer += oprot->writeFieldBegin("devType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->devType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("devIndex", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->devIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->almType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almIndex", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->almIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almFlag", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->almFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almNo", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->almNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almLimit", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->almLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almValue", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->almValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almTime", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->almTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clearLimit", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->clearLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clearValue", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->clearValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clearTime", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64(this->clearTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CAlarm &a, CAlarm &b) {
  using ::std::swap;
  swap(a.devType, b.devType);
  swap(a.devIndex, b.devIndex);
  swap(a.almType, b.almType);
  swap(a.almIndex, b.almIndex);
  swap(a.almFlag, b.almFlag);
  swap(a.almNo, b.almNo);
  swap(a.almLimit, b.almLimit);
  swap(a.almValue, b.almValue);
  swap(a.almTime, b.almTime);
  swap(a.clearLimit, b.clearLimit);
  swap(a.clearValue, b.clearValue);
  swap(a.clearTime, b.clearTime);
  swap(a.__isset, b.__isset);
}

CAlarm::CAlarm(const CAlarm& other128) {
  devType = other128.devType;
  devIndex = other128.devIndex;
  almType = other128.almType;
  almIndex = other128.almIndex;
  almFlag = other128.almFlag;
  almNo = other128.almNo;
  almLimit = other128.almLimit;
  almValue = other128.almValue;
  almTime = other128.almTime;
  clearLimit = other128.clearLimit;
  clearValue = other128.clearValue;
  clearTime = other128.clearTime;
  __isset = other128.__isset;
}
CAlarm& CAlarm::operator=(const CAlarm& other129) {
  devType = other129.devType;
  devIndex = other129.devIndex;
  almType = other129.almType;
  almIndex = other129.almIndex;
  almFlag = other129.almFlag;
  almNo = other129.almNo;
  almLimit = other129.almLimit;
  almValue = other129.almValue;
  almTime = other129.almTime;
  clearLimit = other129.clearLimit;
  clearValue = other129.clearValue;
  clearTime = other129.clearTime;
  __isset = other129.__isset;
  return *this;
}
void CAlarm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CAlarm(";
  out << "devType=" << to_string(devType);
  out << ", " << "devIndex=" << to_string(devIndex);
  out << ", " << "almType=" << to_string(almType);
  out << ", " << "almIndex=" << to_string(almIndex);
  out << ", " << "almFlag=" << to_string(almFlag);
  out << ", " << "almNo=" << to_string(almNo);
  out << ", " << "almLimit=" << to_string(almLimit);
  out << ", " << "almValue=" << to_string(almValue);
  out << ", " << "almTime=" << to_string(almTime);
  out << ", " << "clearLimit=" << to_string(clearLimit);
  out << ", " << "clearValue=" << to_string(clearValue);
  out << ", " << "clearTime=" << to_string(clearTime);
  out << ")";
}


CAlarmMatch::~CAlarmMatch() throw() {
}


void CAlarmMatch::__set_almType(const int32_t val) {
  this->almType = val;
}

void CAlarmMatch::__set_almIndex(const int32_t val) {
  this->almIndex = val;
}

void CAlarmMatch::__set_almNo(const std::string& val) {
  this->almNo = val;
}

void CAlarmMatch::__set_almLimit(const double val) {
  this->almLimit = val;
}

void CAlarmMatch::__set_almValue(const double val) {
  this->almValue = val;
}

void CAlarmMatch::__set_almTime(const int64_t val) {
  this->almTime = val;
}

uint32_t CAlarmMatch::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->almType);
          this->__isset.almType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->almIndex);
          this->__isset.almIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->almNo);
          this->__isset.almNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->almLimit);
          this->__isset.almLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->almValue);
          this->__isset.almValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->almTime);
          this->__isset.almTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CAlarmMatch::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CAlarmMatch");

  xfer += oprot->writeFieldBegin("almType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->almType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almIndex", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->almIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almNo", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->almNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almLimit", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->almLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almValue", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->almValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("almTime", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->almTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CAlarmMatch &a, CAlarmMatch &b) {
  using ::std::swap;
  swap(a.almType, b.almType);
  swap(a.almIndex, b.almIndex);
  swap(a.almNo, b.almNo);
  swap(a.almLimit, b.almLimit);
  swap(a.almValue, b.almValue);
  swap(a.almTime, b.almTime);
  swap(a.__isset, b.__isset);
}

CAlarmMatch::CAlarmMatch(const CAlarmMatch& other130) {
  almType = other130.almType;
  almIndex = other130.almIndex;
  almNo = other130.almNo;
  almLimit = other130.almLimit;
  almValue = other130.almValue;
  almTime = other130.almTime;
  __isset = other130.__isset;
}
CAlarmMatch& CAlarmMatch::operator=(const CAlarmMatch& other131) {
  almType = other131.almType;
  almIndex = other131.almIndex;
  almNo = other131.almNo;
  almLimit = other131.almLimit;
  almValue = other131.almValue;
  almTime = other131.almTime;
  __isset = other131.__isset;
  return *this;
}
void CAlarmMatch::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CAlarmMatch(";
  out << "almType=" << to_string(almType);
  out << ", " << "almIndex=" << to_string(almIndex);
  out << ", " << "almNo=" << to_string(almNo);
  out << ", " << "almLimit=" << to_string(almLimit);
  out << ", " << "almValue=" << to_string(almValue);
  out << ", " << "almTime=" << to_string(almTime);
  out << ")";
}


